<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/prm/musicstreaming/MainActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/prm/musicstreaming/MainActivity.java" />
              <option name="originalContent" value="package com.prm.musicstreaming;&#10;&#10;import android.content.Intent;&#10;import android.graphics.Bitmap;&#10;import android.graphics.Color;&#10;import android.graphics.drawable.BitmapDrawable;&#10;import android.graphics.drawable.Drawable;&#10;import android.graphics.drawable.GradientDrawable;&#10;import android.os.Bundle;&#10;import android.os.Handler;&#10;import android.util.Log;&#10;import android.view.View;&#10;import android.view.WindowManager;&#10;import android.widget.ImageButton;&#10;import android.widget.ImageView;&#10;import android.widget.ProgressBar;&#10;import android.widget.TextView;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.appcompat.app.AppCompatDelegate;&#10;import androidx.appcompat.widget.Toolbar;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.lifecycle.ViewModelProvider;&#10;import androidx.media3.common.util.UnstableApi;&#10;import androidx.navigation.NavController;&#10;import androidx.navigation.NavOptions;&#10;import androidx.navigation.Navigation;&#10;import androidx.navigation.ui.AppBarConfiguration;&#10;import androidx.navigation.ui.NavigationUI;&#10;import androidx.palette.graphics.Palette;&#10;&#10;import com.bumptech.glide.Glide;&#10;import com.bumptech.glide.request.target.CustomTarget;&#10;import com.bumptech.glide.request.transition.Transition;&#10;import com.google.android.gms.ads.AdError;&#10;import com.google.android.gms.ads.AdRequest;&#10;import com.google.android.gms.ads.FullScreenContentCallback;&#10;import com.google.android.gms.ads.LoadAdError;&#10;import com.google.android.gms.ads.MobileAds;&#10;import com.google.android.gms.ads.interstitial.InterstitialAd;&#10;import com.google.android.gms.ads.interstitial.InterstitialAdLoadCallback;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.messaging.FirebaseMessaging;&#10;import com.prm.common.MiniPlayerViewModel;&#10;import com.prm.common.Navigator;&#10;import com.prm.domain.model.Song;&#10;import com.prm.domain.repository.SongRepository;&#10;import com.prm.domain.repository.UserRepository;&#10;import com.prm.payment.result.PaymentSuccessFragment;&#10;&#10;import java.util.Locale;&#10;&#10;import javax.inject.Inject;&#10;&#10;import dagger.hilt.android.AndroidEntryPoint;&#10;import vn.zalopay.sdk.ZaloPaySDK;&#10;&#10;@UnstableApi&#10;@AndroidEntryPoint&#10;public class MainActivity extends AppCompatActivity {&#10;&#10;    private static final String TAG = &quot;MainActivity&quot;;&#10;    private static final long AD_INTERVAL = 60000; // 1 minute in milliseconds&#10;&#10;    private AppBarConfiguration appBarConfiguration;&#10;    private BottomNavigationView navView;&#10;    private Toolbar toolbar;&#10;    private View miniPlayer;&#10;    private NavController navController;&#10;    private MiniPlayerViewModel miniPlayerViewModel;&#10;    private MainViewModel mainViewModel;&#10;&#10;    // Ad related variables&#10;    private InterstitialAd mInterstitialAd;&#10;    private final Handler adHandler = new Handler();&#10;    private Runnable adRunnable;&#10;&#10;    @Inject&#10;    Navigator navigator;&#10;&#10;    @Inject&#10;    SongRepository songRepository;&#10;&#10;    @Inject&#10;    UserRepository userRepository;&#10;&#10;    // Mini player UI components&#10;    private ImageView ivMiniPlayerCover;&#10;    private TextView tvMiniPlayerTitle;&#10;    private TextView tvMiniPlayerArtist;&#10;    private ImageButton btnMiniPlayerPlayPause;&#10;    private ProgressBar miniPlayerProgress;&#10;&#10;    private final Handler progressHandler = new Handler();&#10;    private Runnable progressRunnable;&#10;&#10;    private boolean isNavigatingFromDestinationListener = false;&#10;    private boolean isTopLevelDestination = true;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        // Force dark theme for this activity&#10;        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);&#10;        getWindow().setFlags(&#10;                WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,&#10;                WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS&#10;        );&#10;        setContentView(R.layout.activity_main);&#10;&#10;        // Initialize ViewModels&#10;        miniPlayerViewModel = new ViewModelProvider(this).get(MiniPlayerViewModel.class);&#10;        mainViewModel = new ViewModelProvider(this).get(MainViewModel.class);&#10;&#10;        // Set up observers for ad control&#10;        setupMainViewModelObservers();&#10;&#10;        // Initialize Mobile Ads SDK (will be controlled by user registration status)&#10;        initializeAds();&#10;&#10;        // Subscribe to FCM topic for new songs&#10;        FirebaseMessaging.getInstance().subscribeToTopic(&quot;new_songs&quot;)&#10;                .addOnCompleteListener(task -&gt; {&#10;                    if (task.isSuccessful()) {&#10;                        Log.d(&quot;MainActivity&quot;, &quot;Subscribed to new songs notifications&quot;);&#10;                    } else {&#10;                        Log.e(&quot;MainActivity&quot;, &quot;Failed to subscribe to notifications&quot;, task.getException());&#10;                    }&#10;                });&#10;&#10;        // Set up the toolbar&#10;        toolbar = findViewById(R.id.toolbar);&#10;        setSupportActionBar(toolbar);&#10;&#10;        // Initialize mini player components&#10;        initializeMiniPlayer();&#10;&#10;        // Set up the bottom navigation view&#10;        navView = findViewById(R.id.nav_view);&#10;        appBarConfiguration = new AppBarConfiguration.Builder(&#10;                R.id.navigation_home, R.id.navigation_search, R.id.navigation_library, R.id.navigation_membership_plan)&#10;                .build();&#10;        navController = Navigation.findNavController(this, R.id.nav_host_fragment_activity_main);&#10;        NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);&#10;        NavigationUI.setupWithNavController(navView, navController);&#10;&#10;        // Set up observers for mini player&#10;        setupMiniPlayerObservers();&#10;&#10;        // Connect to music service&#10;        miniPlayerViewModel.connect();&#10;&#10;        // Start ad timer&#10;        startAdTimer();&#10;&#10;        // Add a listener to handle navigation from child fragment back to parent fragment&#10;        navController.addOnDestinationChangedListener((controller, destination, arguments) -&gt; {&#10;            boolean showToolbar =&#10;                    destination.getId() != R.id.navigation_track_view &amp;&amp;&#10;                    destination.getId() != R.id.navigation_notification_permission &amp;&amp;&#10;                    destination.getId() != R.id.navigation_membership_plan &amp;&amp;&#10;                    destination.getId() != R.id.navigation_search_result &amp;&amp;&#10;                    destination.getId() != R.id.navigation_login;&#10;&#10;            boolean showBottomNav =&#10;                    destination.getId() != R.id.navigation_track_view &amp;&amp;&#10;                    destination.getId() != R.id.navigation_edit_profile &amp;&amp;&#10;                    destination.getId() != R.id.navigation_notification_permission &amp;&amp;&#10;                    destination.getId() != R.id.navigation_profile &amp;&amp;&#10;                    destination.getId() != R.id.navigation_checkout &amp;&amp;&#10;                    destination.getId() != R.id.navigation_payment_success &amp;&amp;&#10;                    destination.getId() != R.id.navigation_search_result &amp;&amp;&#10;                    destination.getId() != R.id.navigation_login;&#10;&#10;            toolbar.setVisibility(showToolbar ? View.VISIBLE : View.GONE);&#10;            navView.setVisibility(showBottomNav? View.VISIBLE : View.GONE);&#10;&#10;            boolean showMiniPlayer =&#10;                    destination.getId() == R.id.navigation_home ||&#10;                    destination.getId() == R.id.navigation_search ||&#10;                    destination.getId() == R.id.navigation_library ||&#10;                    destination.getId() == R.id.navigation_membership_plan;&#10;&#10;            Song currentSong = miniPlayerViewModel.getCurrentSong().getValue();&#10;            boolean shouldShow = showMiniPlayer &amp;&amp; currentSong != null;&#10;&#10;            miniPlayer.setVisibility(shouldShow ? View.VISIBLE : View.GONE);&#10;&#10;            // Determine if we're on a top-level destination&#10;            isTopLevelDestination = appBarConfiguration.getTopLevelDestinations()&#10;                    .contains(destination.getId());&#10;&#10;            // Set profile icon for top-level destinations except search, back button for others&#10;            if (destination.getId() == R.id.navigation_search) {&#10;                toolbar.setNavigationIcon(null);&#10;                invalidateOptionsMenu();&#10;            } else if (isTopLevelDestination) {&#10;                this.loadCircularAvatarFromUrl(String.valueOf(FirebaseAuth.getInstance().getCurrentUser().getPhotoUrl()));&#10;                toolbar.setNavigationOnClickListener(v -&gt; navController.navigate(R.id.navigation_profile));&#10;                invalidateOptionsMenu();&#10;            } else {&#10;                toolbar.setNavigationIcon(R.drawable.ic_back);&#10;                toolbar.setNavigationOnClickListener(v -&gt; onSupportNavigateUp());&#10;                invalidateOptionsMenu();&#10;            }&#10;&#10;            // Existing destination changed logic&#10;            if (destination.getId() == R.id.navigation_album &amp;&amp; !isNavigatingFromDestinationListener) {&#10;                isNavigatingFromDestinationListener = true;&#10;                navView.setSelectedItemId(R.id.navigation_home);&#10;                isNavigatingFromDestinationListener = false;&#10;            } else if (destination.getId() == R.id.navigation_checkout &amp;&amp; !isNavigatingFromDestinationListener) {&#10;                isNavigatingFromDestinationListener = true;&#10;                navView.setSelectedItemId(R.id.navigation_membership_plan);&#10;                isNavigatingFromDestinationListener = false;&#10;            } else if (destination.getId() == R.id.navigation_search_result &amp;&amp; !isNavigatingFromDestinationListener) {&#10;                isNavigatingFromDestinationListener = true;&#10;                navView.setSelectedItemId(R.id.navigation_search);&#10;                isNavigatingFromDestinationListener = false;&#10;            }&#10;        });&#10;&#10;        // Add this listener to prevent navigation when we're just updating UI&#10;        navView.setOnItemSelectedListener(item -&gt; {&#10;            if (isNavigatingFromDestinationListener) {&#10;                return true;&#10;            }&#10;            return NavigationUI.onNavDestinationSelected(item, navController) || super.onOptionsItemSelected(item);&#10;        });&#10;&#10;        if (FirebaseAuth.getInstance().getCurrentUser() != null) {&#10;            navigator.clearAndNavigate(com.prm.common.R.string.route_home);&#10;        }&#10;    }&#10;&#10;    private void setupMainViewModelObservers() {&#10;        mainViewModel.shouldShowAds.observe(this, shouldShowAds -&gt; {&#10;            if (shouldShowAds) {&#10;                // User is not registered, show ads&#10;                startAdTimer();&#10;            } else {&#10;                // User is registered, turn off ads&#10;                stopAdTimer();&#10;                Log.d(TAG, &quot;Ads disabled for registered user&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void initializeAds() {&#10;        // Check if ads should be shown before initializing&#10;        Boolean shouldShowAds = mainViewModel.shouldShowAds.getValue();&#10;        if (shouldShowAds == null || !shouldShowAds) {&#10;            Log.d(TAG, &quot;Ads initialization skipped - user is registered&quot;);&#10;            return;&#10;        }&#10;&#10;        MobileAds.initialize(this, initializationStatus -&gt; {&#10;            Log.d(TAG, &quot;MobileAds initialized&quot;);&#10;            loadInterstitialAd();&#10;        });&#10;    }&#10;&#10;    private void loadInterstitialAd() {&#10;        // Double check if ads should still be shown&#10;        Boolean shouldShowAds = mainViewModel.shouldShowAds.getValue();&#10;        if (shouldShowAds == null || !shouldShowAds) {&#10;            Log.d(TAG, &quot;Ad loading cancelled - user is registered&quot;);&#10;            return;&#10;        }&#10;&#10;        AdRequest adRequest = new AdRequest.Builder().build();&#10;        InterstitialAd.load(this, getString(R.string.interstitial_ad_unit_id), adRequest,&#10;                new InterstitialAdLoadCallback() {&#10;                    @Override&#10;                    public void onAdLoaded(@NonNull InterstitialAd interstitialAd) {&#10;                        mInterstitialAd = interstitialAd;&#10;                        Log.d(TAG, &quot;Interstitial ad loaded successfully&quot;);&#10;&#10;                        interstitialAd.setFullScreenContentCallback(&#10;                                new FullScreenContentCallback() {&#10;                                    @Override&#10;                                    public void onAdDismissedFullScreenContent() {&#10;                                        mInterstitialAd = null;&#10;                                        Log.d(TAG, &quot;The ad was dismissed.&quot;);&#10;                                        // Load a new ad for the next time&#10;                                        loadInterstitialAd();&#10;                                    }&#10;&#10;                                    @Override&#10;                                    public void onAdFailedToShowFullScreenContent(@NonNull AdError adError) {&#10;                                        mInterstitialAd = null;&#10;                                        Log.d(TAG, &quot;The ad failed to show: &quot; + adError.getMessage());&#10;                                        // Load a new ad for the next time&#10;                                        loadInterstitialAd();&#10;                                    }&#10;&#10;                                    @Override&#10;                                    public void onAdShowedFullScreenContent() {&#10;                                        Log.d(TAG, &quot;The ad was shown.&quot;);&#10;                                        boolean isPlaying = Boolean.TRUE.equals(miniPlayerViewModel.getIsPlaying().getValue());&#10;                                        if (isPlaying) {&#10;                                            miniPlayerViewModel.playPause();&#10;                                        }&#10;                                    }&#10;                                });&#10;                    }&#10;&#10;                    @Override&#10;                    public void onAdFailedToLoad(@NonNull LoadAdError loadAdError) {&#10;                        Log.i(TAG, &quot;Failed to load interstitial ad: &quot; + loadAdError.getMessage());&#10;                        mInterstitialAd = null;&#10;&#10;                        String error = String.format(&#10;                                Locale.ENGLISH,&#10;                                &quot;domain: %s, code: %d, message: %s&quot;,&#10;                                loadAdError.getDomain(),&#10;                                loadAdError.getCode(),&#10;                                loadAdError.getMessage());&#10;&#10;                        Log.e(TAG, &quot;onAdFailedToLoad() with error: &quot; + error);&#10;&#10;                        // Retry loading ad after a delay (e.g., 30 seconds)&#10;                        adHandler.postDelayed(() -&gt; loadInterstitialAd(), 30000);&#10;                    }&#10;                });&#10;    }&#10;&#10;    private void showInterstitialAd() {&#10;        // Check if ads should be shown before displaying&#10;        Boolean shouldShowAds = mainViewModel.shouldShowAds.getValue();&#10;        if (shouldShowAds == null || !shouldShowAds) {&#10;            Log.d(TAG, &quot;Ad display cancelled - user is registered&quot;);&#10;            return;&#10;        }&#10;&#10;        if (mInterstitialAd != null) {&#10;            mInterstitialAd.show(this);&#10;        } else {&#10;            Log.d(TAG, &quot;The interstitial ad wasn't ready yet.&quot;);&#10;            // Try to load a new ad&#10;            loadInterstitialAd();&#10;        }&#10;    }&#10;&#10;    private void startAdTimer() {&#10;        // Check if ads should be shown before starting timer&#10;        Boolean shouldShowAds = mainViewModel.shouldShowAds.getValue();&#10;        if (shouldShowAds == null || !shouldShowAds) {&#10;            Log.d(TAG, &quot;Ad timer start cancelled - user is registered&quot;);&#10;            return;&#10;        }&#10;&#10;        if (adRunnable == null) {&#10;            adRunnable = new Runnable() {&#10;                @Override&#10;                public void run() {&#10;                    showInterstitialAd();&#10;                    adHandler.postDelayed(this, AD_INTERVAL);&#10;                }&#10;            };&#10;        }&#10;        // Start the first ad after 1 minute&#10;        adHandler.postDelayed(adRunnable, AD_INTERVAL);&#10;    }&#10;&#10;    private void stopAdTimer() {&#10;        if (adRunnable != null) {&#10;            adHandler.removeCallbacks(adRunnable);&#10;        }&#10;    }&#10;&#10;    private void loadCircularAvatarFromUrl(String imageUrl) {&#10;        int iconSize = (int) (30 * getResources().getDisplayMetrics().density); // 30dp&#10;&#10;        Glide.with(this)&#10;                .asBitmap()&#10;                .load(imageUrl)&#10;                .placeholder(R.drawable.ic_profile)&#10;                .error(R.drawable.ic_profile)&#10;                .override(iconSize, iconSize)&#10;                .circleCrop()&#10;                .into(new CustomTarget&lt;Bitmap&gt;() {&#10;                    @Override&#10;                    public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) {&#10;                        toolbar.setNavigationIcon(new BitmapDrawable(getResources(), resource));&#10;                    }&#10;&#10;                    @Override&#10;                    public void onLoadCleared(@Nullable Drawable placeholder) {&#10;                        toolbar.setNavigationIcon(R.drawable.ic_profile);&#10;                    }&#10;                });&#10;    }&#10;&#10;    private void initializeMiniPlayer() {&#10;        miniPlayer = findViewById(R.id.mini_player);&#10;        ivMiniPlayerCover = miniPlayer.findViewById(R.id.iv_mini_player_cover);&#10;        tvMiniPlayerTitle = miniPlayer.findViewById(R.id.tv_mini_player_title);&#10;        tvMiniPlayerArtist = miniPlayer.findViewById(R.id.tv_mini_player_artist);&#10;        btnMiniPlayerPlayPause = miniPlayer.findViewById(R.id.btn_mini_player_play_pause);&#10;        miniPlayerProgress = miniPlayer.findViewById(R.id.mini_player_progress);&#10;&#10;        btnMiniPlayerPlayPause.setOnClickListener(v -&gt; miniPlayerViewModel.playPause());&#10;&#10;        miniPlayer.setOnClickListener(v -&gt; {&#10;            NavOptions navOptions = new NavOptions.Builder()&#10;                    .setPopUpTo(R.id.navigation_home, false)&#10;                    .build();&#10;            navController.navigate(R.id.navigation_track_view, null, navOptions);&#10;        });&#10;    }&#10;&#10;    private void setupMiniPlayerObservers() {&#10;        miniPlayerViewModel.getCurrentSong().observe(this, this::updateMiniPlayerSong);&#10;        miniPlayerViewModel.getIsPlaying().observe(this, this::updatePlayPauseButton);&#10;&#10;        // Observe progress for mini player&#10;        miniPlayerViewModel.getCurrentPosition().observe(this, this::updateMiniPlayerProgress);&#10;        miniPlayerViewModel.getDuration().observe(this, this::updateMiniPlayerDuration);&#10;&#10;        miniPlayerViewModel.getIsPlaying().observe(this, isPlaying -&gt; {&#10;            if (isPlaying) {&#10;                startProgressUpdates();&#10;            } else {&#10;                stopProgressUpdates();&#10;            }&#10;        });&#10;    }&#10;&#10;    private void updateMiniPlayerProgress(Long position) {&#10;        if (position != null &amp;&amp; miniPlayerProgress.getMax() &gt; 0) {&#10;            int progress = (int) (position / 1000);&#10;            miniPlayerProgress.setProgress(progress);&#10;        }&#10;    }&#10;&#10;    private void updateMiniPlayerDuration(Long duration) {&#10;        if (duration != null &amp;&amp; duration &gt; 0) {&#10;            int durationInSeconds = (int) (duration / 1000);&#10;            miniPlayerProgress.setMax(durationInSeconds);&#10;        }&#10;    }&#10;&#10;    private void updateMiniPlayerSong(Song song) {&#10;        if (song != null) {&#10;            tvMiniPlayerTitle.setText(song.getTitle());&#10;            tvMiniPlayerArtist.setText(song.getArtistId()); // You might want to resolve artist name&#10;            miniPlayer.setVisibility(View.VISIBLE);&#10;&#10;            Glide.with(this)&#10;                    .asBitmap()&#10;                    .load(song.getImageUrl())&#10;                    .placeholder(com.prm.common.R.drawable.ic_music_note)&#10;                    .error(com.prm.common.R.drawable.ic_music_note)&#10;                    .into(new CustomTarget&lt;Bitmap&gt;() {&#10;                        @Override&#10;                        public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) {&#10;                            ivMiniPlayerCover.setImageBitmap(resource);&#10;                            extractColorAndSetMiniPlayerGradient(resource);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onLoadCleared(@Nullable Drawable placeholder) {&#10;                            ivMiniPlayerCover.setImageDrawable(placeholder);&#10;                        }&#10;                    });&#10;        } else {&#10;            miniPlayer.setVisibility(View.GONE);&#10;        }&#10;    }&#10;&#10;    private void extractColorAndSetMiniPlayerGradient(Bitmap bitmap) {&#10;        Palette.from(bitmap).generate(palette -&gt; {&#10;            int dominantColor = palette.getDominantColor(0xFF424242);&#10;&#10;            int endColor = darkenColor(dominantColor, 0.1f);&#10;&#10;            GradientDrawable gradientDrawable = new GradientDrawable();&#10;            gradientDrawable.setColor(endColor);&#10;            gradientDrawable.setCornerRadius(8 * getResources().getDisplayMetrics().density);&#10;&#10;            miniPlayer.setBackground(gradientDrawable);&#10;            miniPlayer.setClipToOutline(true);&#10;        });&#10;    }&#10;&#10;    private int darkenColor(int color, float factor) {&#10;        float[] hsv = new float[3];&#10;        Color.colorToHSV(color, hsv);&#10;        hsv[2] *= (1 - factor);&#10;&#10;        if (hsv[2] &gt; 0.9f) {&#10;            hsv[2] = 0.9f;&#10;        }&#10;&#10;        return Color.HSVToColor(hsv);&#10;    }&#10;&#10;    private void updatePlayPauseButton(Boolean isPlaying) {&#10;        if (isPlaying != null &amp;&amp; isPlaying) {&#10;            btnMiniPlayerPlayPause.setImageResource(com.prm.common.R.drawable.ic_pause);&#10;        } else {&#10;            btnMiniPlayerPlayPause.setImageResource(com.prm.common.R.drawable.ic_play);&#10;        }&#10;    }&#10;&#10;    private void startProgressUpdates() {&#10;        if (progressRunnable == null) {&#10;            progressRunnable = new Runnable() {&#10;                @Override&#10;                public void run() {&#10;                    miniPlayerViewModel.updateProgress();&#10;                    progressHandler.postDelayed(this, 1000); // Update every second&#10;                }&#10;            };&#10;        }&#10;        progressHandler.post(progressRunnable);&#10;    }&#10;&#10;    private void stopProgressUpdates() {&#10;        if (progressRunnable != null) {&#10;            progressHandler.removeCallbacks(progressRunnable);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean onSupportNavigateUp() {&#10;        // Get the current fragment&#10;        Fragment currentFragment = getSupportFragmentManager()&#10;                .findFragmentById(R.id.nav_host_fragment_activity_main)&#10;                .getChildFragmentManager()&#10;                .getPrimaryNavigationFragment();&#10;&#10;        // Handle special cases&#10;        if (currentFragment instanceof PaymentSuccessFragment) {&#10;            navigator.navigate(com.prm.common.R.string.route_plan_management);&#10;            return true;&#10;        }&#10;&#10;        return NavigationUI.navigateUp(navController, appBarConfiguration)&#10;               || super.onSupportNavigateUp();&#10;    }&#10;&#10;    @Override&#10;    protected void onNewIntent(Intent intent) {&#10;        super.onNewIntent(intent);&#10;        try {&#10;            ZaloPaySDK.getInstance().onResult(intent);&#10;        } catch (Exception e) {&#10;            Log.e(&quot;MainActivity&quot;, &quot;Error handling ZaloPay result&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        // Pause ad timer when activity is not visible&#10;        stopAdTimer();&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        // Resume ad timer when activity becomes visible&#10;        startAdTimer();&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        stopProgressUpdates();&#10;        stopAdTimer();&#10;        if (miniPlayerViewModel != null) {&#10;            miniPlayerViewModel.disconnect();&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.prm.musicstreaming;&#10;&#10;import android.content.Intent;&#10;import android.graphics.Bitmap;&#10;import android.graphics.Color;&#10;import android.graphics.drawable.BitmapDrawable;&#10;import android.graphics.drawable.Drawable;&#10;import android.graphics.drawable.GradientDrawable;&#10;import android.os.Bundle;&#10;import android.os.Handler;&#10;import android.util.Log;&#10;import android.view.View;&#10;import android.view.WindowManager;&#10;import android.widget.ImageButton;&#10;import android.widget.ImageView;&#10;import android.widget.ProgressBar;&#10;import android.widget.TextView;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.appcompat.app.AppCompatDelegate;&#10;import androidx.appcompat.widget.Toolbar;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.lifecycle.ViewModelProvider;&#10;import androidx.media3.common.util.UnstableApi;&#10;import androidx.navigation.NavController;&#10;import androidx.navigation.NavOptions;&#10;import androidx.navigation.Navigation;&#10;import androidx.navigation.ui.AppBarConfiguration;&#10;import androidx.navigation.ui.NavigationUI;&#10;import androidx.palette.graphics.Palette;&#10;&#10;import com.bumptech.glide.Glide;&#10;import com.bumptech.glide.request.target.CustomTarget;&#10;import com.bumptech.glide.request.transition.Transition;&#10;import com.google.android.gms.ads.AdError;&#10;import com.google.android.gms.ads.AdRequest;&#10;import com.google.android.gms.ads.FullScreenContentCallback;&#10;import com.google.android.gms.ads.LoadAdError;&#10;import com.google.android.gms.ads.MobileAds;&#10;import com.google.android.gms.ads.interstitial.InterstitialAd;&#10;import com.google.android.gms.ads.interstitial.InterstitialAdLoadCallback;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.messaging.FirebaseMessaging;&#10;import com.prm.common.MiniPlayerViewModel;&#10;import com.prm.common.Navigator;&#10;import com.prm.domain.model.Song;&#10;import com.prm.domain.repository.SongRepository;&#10;import com.prm.domain.repository.UserRepository;&#10;import com.prm.payment.result.PaymentSuccessFragment;&#10;&#10;import java.util.Locale;&#10;&#10;import javax.inject.Inject;&#10;&#10;import dagger.hilt.android.AndroidEntryPoint;&#10;import vn.zalopay.sdk.ZaloPaySDK;&#10;&#10;@UnstableApi&#10;@AndroidEntryPoint&#10;public class MainActivity extends AppCompatActivity {&#10;&#10;    private static final String TAG = &quot;MainActivity&quot;;&#10;    private static final long AD_INTERVAL = 60000; // 1 minute in milliseconds&#10;&#10;    private AppBarConfiguration appBarConfiguration;&#10;    private BottomNavigationView navView;&#10;    private Toolbar toolbar;&#10;    private View miniPlayer;&#10;    private NavController navController;&#10;    private MiniPlayerViewModel miniPlayerViewModel;&#10;    private MainViewModel mainViewModel;&#10;&#10;    // Ad related variables&#10;    private InterstitialAd mInterstitialAd;&#10;    private final Handler adHandler = new Handler();&#10;    private Runnable adRunnable;&#10;&#10;    @Inject&#10;    Navigator navigator;&#10;&#10;    @Inject&#10;    SongRepository songRepository;&#10;&#10;    @Inject&#10;    UserRepository userRepository;&#10;&#10;    // Mini player UI components&#10;    private ImageView ivMiniPlayerCover;&#10;    private TextView tvMiniPlayerTitle;&#10;    private TextView tvMiniPlayerArtist;&#10;    private ImageButton btnMiniPlayerPlayPause;&#10;    private ProgressBar miniPlayerProgress;&#10;&#10;    private final Handler progressHandler = new Handler();&#10;    private Runnable progressRunnable;&#10;&#10;    private boolean isNavigatingFromDestinationListener = false;&#10;    private boolean isTopLevelDestination = true;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        // Force dark theme for this activity&#10;        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);&#10;        getWindow().setFlags(&#10;                WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,&#10;                WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS&#10;        );&#10;        setContentView(R.layout.activity_main);&#10;&#10;        // Initialize ViewModels&#10;        miniPlayerViewModel = new ViewModelProvider(this).get(MiniPlayerViewModel.class);&#10;        mainViewModel = new ViewModelProvider(this).get(MainViewModel.class);&#10;&#10;        // Set up observers for ad control&#10;        setupMainViewModelObservers();&#10;&#10;        // Initialize Mobile Ads SDK (will be controlled by user registration status)&#10;        initializeAds();&#10;&#10;        // Subscribe to FCM topic for new songs&#10;        FirebaseMessaging.getInstance().subscribeToTopic(&quot;new_songs&quot;)&#10;                .addOnCompleteListener(task -&gt; {&#10;                    if (task.isSuccessful()) {&#10;                        Log.d(&quot;MainActivity&quot;, &quot;Subscribed to new songs notifications&quot;);&#10;                    } else {&#10;                        Log.e(&quot;MainActivity&quot;, &quot;Failed to subscribe to notifications&quot;, task.getException());&#10;                    }&#10;                });&#10;&#10;        // Set up the toolbar&#10;        toolbar = findViewById(R.id.toolbar);&#10;        setSupportActionBar(toolbar);&#10;&#10;        // Initialize mini player components&#10;        initializeMiniPlayer();&#10;&#10;        // Set up the bottom navigation view&#10;        navView = findViewById(R.id.nav_view);&#10;        appBarConfiguration = new AppBarConfiguration.Builder(&#10;                R.id.navigation_home, R.id.navigation_search, R.id.navigation_library, R.id.navigation_membership_plan)&#10;                .build();&#10;        navController = Navigation.findNavController(this, R.id.nav_host_fragment_activity_main);&#10;        NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);&#10;        NavigationUI.setupWithNavController(navView, navController);&#10;&#10;        // Set up observers for mini player&#10;        setupMiniPlayerObservers();&#10;&#10;        // Connect to music service&#10;        miniPlayerViewModel.connect();&#10;&#10;        // Add a listener to handle navigation from child fragment back to parent fragment&#10;        navController.addOnDestinationChangedListener((controller, destination, arguments) -&gt; {&#10;            boolean showToolbar =&#10;                    destination.getId() != R.id.navigation_track_view &amp;&amp;&#10;                    destination.getId() != R.id.navigation_notification_permission &amp;&amp;&#10;                    destination.getId() != R.id.navigation_membership_plan &amp;&amp;&#10;                    destination.getId() != R.id.navigation_search_result &amp;&amp;&#10;                    destination.getId() != R.id.navigation_login;&#10;&#10;            boolean showBottomNav =&#10;                    destination.getId() != R.id.navigation_track_view &amp;&amp;&#10;                    destination.getId() != R.id.navigation_edit_profile &amp;&amp;&#10;                    destination.getId() != R.id.navigation_notification_permission &amp;&amp;&#10;                    destination.getId() != R.id.navigation_profile &amp;&amp;&#10;                    destination.getId() != R.id.navigation_checkout &amp;&amp;&#10;                    destination.getId() != R.id.navigation_payment_success &amp;&amp;&#10;                    destination.getId() != R.id.navigation_search_result &amp;&amp;&#10;                    destination.getId() != R.id.navigation_login;&#10;&#10;            toolbar.setVisibility(showToolbar ? View.VISIBLE : View.GONE);&#10;            navView.setVisibility(showBottomNav? View.VISIBLE : View.GONE);&#10;&#10;            boolean showMiniPlayer =&#10;                    destination.getId() == R.id.navigation_home ||&#10;                    destination.getId() == R.id.navigation_search ||&#10;                    destination.getId() == R.id.navigation_library ||&#10;                    destination.getId() == R.id.navigation_membership_plan;&#10;&#10;            Song currentSong = miniPlayerViewModel.getCurrentSong().getValue();&#10;            boolean shouldShow = showMiniPlayer &amp;&amp; currentSong != null;&#10;&#10;            miniPlayer.setVisibility(shouldShow ? View.VISIBLE : View.GONE);&#10;&#10;            // Determine if we're on a top-level destination&#10;            isTopLevelDestination = appBarConfiguration.getTopLevelDestinations()&#10;                    .contains(destination.getId());&#10;&#10;            // Set profile icon for top-level destinations except search, back button for others&#10;            if (destination.getId() == R.id.navigation_search) {&#10;                toolbar.setNavigationIcon(null);&#10;                invalidateOptionsMenu();&#10;            } else if (isTopLevelDestination) {&#10;                this.loadCircularAvatarFromUrl(String.valueOf(FirebaseAuth.getInstance().getCurrentUser().getPhotoUrl()));&#10;                toolbar.setNavigationOnClickListener(v -&gt; navController.navigate(R.id.navigation_profile));&#10;                invalidateOptionsMenu();&#10;            } else {&#10;                toolbar.setNavigationIcon(R.drawable.ic_back);&#10;                toolbar.setNavigationOnClickListener(v -&gt; onSupportNavigateUp());&#10;                invalidateOptionsMenu();&#10;            }&#10;&#10;            // Existing destination changed logic&#10;            if (destination.getId() == R.id.navigation_album &amp;&amp; !isNavigatingFromDestinationListener) {&#10;                isNavigatingFromDestinationListener = true;&#10;                navView.setSelectedItemId(R.id.navigation_home);&#10;                isNavigatingFromDestinationListener = false;&#10;            } else if (destination.getId() == R.id.navigation_checkout &amp;&amp; !isNavigatingFromDestinationListener) {&#10;                isNavigatingFromDestinationListener = true;&#10;                navView.setSelectedItemId(R.id.navigation_membership_plan);&#10;                isNavigatingFromDestinationListener = false;&#10;            } else if (destination.getId() == R.id.navigation_search_result &amp;&amp; !isNavigatingFromDestinationListener) {&#10;                isNavigatingFromDestinationListener = true;&#10;                navView.setSelectedItemId(R.id.navigation_search);&#10;                isNavigatingFromDestinationListener = false;&#10;            }&#10;        });&#10;&#10;        // Add this listener to prevent navigation when we're just updating UI&#10;        navView.setOnItemSelectedListener(item -&gt; {&#10;            if (isNavigatingFromDestinationListener) {&#10;                return true;&#10;            }&#10;            return NavigationUI.onNavDestinationSelected(item, navController) || super.onOptionsItemSelected(item);&#10;        });&#10;&#10;        if (FirebaseAuth.getInstance().getCurrentUser() != null) {&#10;            navigator.clearAndNavigate(com.prm.common.R.string.route_home);&#10;        }&#10;    }&#10;&#10;    private void setupMainViewModelObservers() {&#10;        mainViewModel.shouldShowAds.observe(this, shouldShowAds -&gt; {&#10;            if (shouldShowAds) {&#10;                // User is not registered, show ads&#10;                startAdTimer();&#10;            } else {&#10;                // User is registered, turn off ads&#10;                stopAdTimer();&#10;                Log.d(TAG, &quot;Ads disabled for registered user&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void initializeAds() {&#10;        // Check if ads should be shown before initializing&#10;        Boolean shouldShowAds = mainViewModel.shouldShowAds.getValue();&#10;        if (shouldShowAds == null || !shouldShowAds) {&#10;            Log.d(TAG, &quot;Ads initialization skipped - user is registered&quot;);&#10;            return;&#10;        }&#10;&#10;        MobileAds.initialize(this, initializationStatus -&gt; {&#10;            Log.d(TAG, &quot;MobileAds initialized&quot;);&#10;            loadInterstitialAd();&#10;        });&#10;    }&#10;&#10;    private void loadInterstitialAd() {&#10;        // Double check if ads should still be shown&#10;        Boolean shouldShowAds = mainViewModel.shouldShowAds.getValue();&#10;        if (shouldShowAds == null || !shouldShowAds) {&#10;            Log.d(TAG, &quot;Ad loading cancelled - user is registered&quot;);&#10;            return;&#10;        }&#10;&#10;        AdRequest adRequest = new AdRequest.Builder().build();&#10;        InterstitialAd.load(this, getString(R.string.interstitial_ad_unit_id), adRequest,&#10;                new InterstitialAdLoadCallback() {&#10;                    @Override&#10;                    public void onAdLoaded(@NonNull InterstitialAd interstitialAd) {&#10;                        mInterstitialAd = interstitialAd;&#10;                        Log.d(TAG, &quot;Interstitial ad loaded successfully&quot;);&#10;&#10;                        interstitialAd.setFullScreenContentCallback(&#10;                                new FullScreenContentCallback() {&#10;                                    @Override&#10;                                    public void onAdDismissedFullScreenContent() {&#10;                                        mInterstitialAd = null;&#10;                                        Log.d(TAG, &quot;The ad was dismissed.&quot;);&#10;                                        // Load a new ad for the next time&#10;                                        loadInterstitialAd();&#10;                                    }&#10;&#10;                                    @Override&#10;                                    public void onAdFailedToShowFullScreenContent(@NonNull AdError adError) {&#10;                                        mInterstitialAd = null;&#10;                                        Log.d(TAG, &quot;The ad failed to show: &quot; + adError.getMessage());&#10;                                        // Load a new ad for the next time&#10;                                        loadInterstitialAd();&#10;                                    }&#10;&#10;                                    @Override&#10;                                    public void onAdShowedFullScreenContent() {&#10;                                        Log.d(TAG, &quot;The ad was shown.&quot;);&#10;                                        boolean isPlaying = Boolean.TRUE.equals(miniPlayerViewModel.getIsPlaying().getValue());&#10;                                        if (isPlaying) {&#10;                                            miniPlayerViewModel.playPause();&#10;                                        }&#10;                                    }&#10;                                });&#10;                    }&#10;&#10;                    @Override&#10;                    public void onAdFailedToLoad(@NonNull LoadAdError loadAdError) {&#10;                        Log.i(TAG, &quot;Failed to load interstitial ad: &quot; + loadAdError.getMessage());&#10;                        mInterstitialAd = null;&#10;&#10;                        String error = String.format(&#10;                                Locale.ENGLISH,&#10;                                &quot;domain: %s, code: %d, message: %s&quot;,&#10;                                loadAdError.getDomain(),&#10;                                loadAdError.getCode(),&#10;                                loadAdError.getMessage());&#10;&#10;                        Log.e(TAG, &quot;onAdFailedToLoad() with error: &quot; + error);&#10;&#10;                        // Retry loading ad after a delay (e.g., 30 seconds)&#10;                        adHandler.postDelayed(() -&gt; loadInterstitialAd(), 30000);&#10;                    }&#10;                });&#10;    }&#10;&#10;    private void showInterstitialAd() {&#10;        // Check if ads should be shown before displaying&#10;        Boolean shouldShowAds = mainViewModel.shouldShowAds.getValue();&#10;        if (shouldShowAds == null || !shouldShowAds) {&#10;            Log.d(TAG, &quot;Ad display cancelled - user is registered&quot;);&#10;            return;&#10;        }&#10;&#10;        if (mInterstitialAd != null) {&#10;            mInterstitialAd.show(this);&#10;        } else {&#10;            Log.d(TAG, &quot;The interstitial ad wasn't ready yet.&quot;);&#10;            // Try to load a new ad&#10;            loadInterstitialAd();&#10;        }&#10;    }&#10;&#10;    private void startAdTimer() {&#10;        // Check if ads should be shown before starting timer&#10;        Boolean shouldShowAds = mainViewModel.shouldShowAds.getValue();&#10;        if (shouldShowAds == null || !shouldShowAds) {&#10;            Log.d(TAG, &quot;Ad timer start cancelled - user is registered&quot;);&#10;            return;&#10;        }&#10;&#10;        if (adRunnable == null) {&#10;            adRunnable = new Runnable() {&#10;                @Override&#10;                public void run() {&#10;                    showInterstitialAd();&#10;                    adHandler.postDelayed(this, AD_INTERVAL);&#10;                }&#10;            };&#10;        }&#10;        // Start the first ad after 1 minute&#10;        adHandler.postDelayed(adRunnable, AD_INTERVAL);&#10;    }&#10;&#10;    private void stopAdTimer() {&#10;        if (adRunnable != null) {&#10;            adHandler.removeCallbacks(adRunnable);&#10;        }&#10;    }&#10;&#10;    private void loadCircularAvatarFromUrl(String imageUrl) {&#10;        int iconSize = (int) (30 * getResources().getDisplayMetrics().density); // 30dp&#10;&#10;        Glide.with(this)&#10;                .asBitmap()&#10;                .load(imageUrl)&#10;                .placeholder(R.drawable.ic_profile)&#10;                .error(R.drawable.ic_profile)&#10;                .override(iconSize, iconSize)&#10;                .circleCrop()&#10;                .into(new CustomTarget&lt;Bitmap&gt;() {&#10;                    @Override&#10;                    public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) {&#10;                        toolbar.setNavigationIcon(new BitmapDrawable(getResources(), resource));&#10;                    }&#10;&#10;                    @Override&#10;                    public void onLoadCleared(@Nullable Drawable placeholder) {&#10;                        toolbar.setNavigationIcon(R.drawable.ic_profile);&#10;                    }&#10;                });&#10;    }&#10;&#10;    private void initializeMiniPlayer() {&#10;        miniPlayer = findViewById(R.id.mini_player);&#10;        ivMiniPlayerCover = miniPlayer.findViewById(R.id.iv_mini_player_cover);&#10;        tvMiniPlayerTitle = miniPlayer.findViewById(R.id.tv_mini_player_title);&#10;        tvMiniPlayerArtist = miniPlayer.findViewById(R.id.tv_mini_player_artist);&#10;        btnMiniPlayerPlayPause = miniPlayer.findViewById(R.id.btn_mini_player_play_pause);&#10;        miniPlayerProgress = miniPlayer.findViewById(R.id.mini_player_progress);&#10;&#10;        btnMiniPlayerPlayPause.setOnClickListener(v -&gt; miniPlayerViewModel.playPause());&#10;&#10;        miniPlayer.setOnClickListener(v -&gt; {&#10;            NavOptions navOptions = new NavOptions.Builder()&#10;                    .setPopUpTo(R.id.navigation_home, false)&#10;                    .build();&#10;            navController.navigate(R.id.navigation_track_view, null, navOptions);&#10;        });&#10;    }&#10;&#10;    private void setupMiniPlayerObservers() {&#10;        miniPlayerViewModel.getCurrentSong().observe(this, this::updateMiniPlayerSong);&#10;        miniPlayerViewModel.getIsPlaying().observe(this, this::updatePlayPauseButton);&#10;&#10;        // Observe progress for mini player&#10;        miniPlayerViewModel.getCurrentPosition().observe(this, this::updateMiniPlayerProgress);&#10;        miniPlayerViewModel.getDuration().observe(this, this::updateMiniPlayerDuration);&#10;&#10;        miniPlayerViewModel.getIsPlaying().observe(this, isPlaying -&gt; {&#10;            if (isPlaying) {&#10;                startProgressUpdates();&#10;            } else {&#10;                stopProgressUpdates();&#10;            }&#10;        });&#10;    }&#10;&#10;    private void updateMiniPlayerProgress(Long position) {&#10;        if (position != null &amp;&amp; miniPlayerProgress.getMax() &gt; 0) {&#10;            int progress = (int) (position / 1000);&#10;            miniPlayerProgress.setProgress(progress);&#10;        }&#10;    }&#10;&#10;    private void updateMiniPlayerDuration(Long duration) {&#10;        if (duration != null &amp;&amp; duration &gt; 0) {&#10;            int durationInSeconds = (int) (duration / 1000);&#10;            miniPlayerProgress.setMax(durationInSeconds);&#10;        }&#10;    }&#10;&#10;    private void updateMiniPlayerSong(Song song) {&#10;        if (song != null) {&#10;            tvMiniPlayerTitle.setText(song.getTitle());&#10;            tvMiniPlayerArtist.setText(song.getArtistId()); // You might want to resolve artist name&#10;            miniPlayer.setVisibility(View.VISIBLE);&#10;&#10;            Glide.with(this)&#10;                    .asBitmap()&#10;                    .load(song.getImageUrl())&#10;                    .placeholder(com.prm.common.R.drawable.ic_music_note)&#10;                    .error(com.prm.common.R.drawable.ic_music_note)&#10;                    .into(new CustomTarget&lt;Bitmap&gt;() {&#10;                        @Override&#10;                        public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) {&#10;                            ivMiniPlayerCover.setImageBitmap(resource);&#10;                            extractColorAndSetMiniPlayerGradient(resource);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onLoadCleared(@Nullable Drawable placeholder) {&#10;                            ivMiniPlayerCover.setImageDrawable(placeholder);&#10;                        }&#10;                    });&#10;        } else {&#10;            miniPlayer.setVisibility(View.GONE);&#10;        }&#10;    }&#10;&#10;    private void extractColorAndSetMiniPlayerGradient(Bitmap bitmap) {&#10;        Palette.from(bitmap).generate(palette -&gt; {&#10;            int dominantColor = palette.getDominantColor(0xFF424242);&#10;&#10;            int endColor = darkenColor(dominantColor, 0.1f);&#10;&#10;            GradientDrawable gradientDrawable = new GradientDrawable();&#10;            gradientDrawable.setColor(endColor);&#10;            gradientDrawable.setCornerRadius(8 * getResources().getDisplayMetrics().density);&#10;&#10;            miniPlayer.setBackground(gradientDrawable);&#10;            miniPlayer.setClipToOutline(true);&#10;        });&#10;    }&#10;&#10;    private int darkenColor(int color, float factor) {&#10;        float[] hsv = new float[3];&#10;        Color.colorToHSV(color, hsv);&#10;        hsv[2] *= (1 - factor);&#10;&#10;        if (hsv[2] &gt; 0.9f) {&#10;            hsv[2] = 0.9f;&#10;        }&#10;&#10;        return Color.HSVToColor(hsv);&#10;    }&#10;&#10;    private void updatePlayPauseButton(Boolean isPlaying) {&#10;        if (isPlaying != null &amp;&amp; isPlaying) {&#10;            btnMiniPlayerPlayPause.setImageResource(com.prm.common.R.drawable.ic_pause);&#10;        } else {&#10;            btnMiniPlayerPlayPause.setImageResource(com.prm.common.R.drawable.ic_play);&#10;        }&#10;    }&#10;&#10;    private void startProgressUpdates() {&#10;        if (progressRunnable == null) {&#10;            progressRunnable = new Runnable() {&#10;                @Override&#10;                public void run() {&#10;                    miniPlayerViewModel.updateProgress();&#10;                    progressHandler.postDelayed(this, 1000); // Update every second&#10;                }&#10;            };&#10;        }&#10;        progressHandler.post(progressRunnable);&#10;    }&#10;&#10;    private void stopProgressUpdates() {&#10;        if (progressRunnable != null) {&#10;            progressHandler.removeCallbacks(progressRunnable);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean onSupportNavigateUp() {&#10;        // Get the current fragment&#10;        Fragment currentFragment = getSupportFragmentManager()&#10;                .findFragmentById(R.id.nav_host_fragment_activity_main)&#10;                .getChildFragmentManager()&#10;                .getPrimaryNavigationFragment();&#10;&#10;        // Handle special cases&#10;        if (currentFragment instanceof PaymentSuccessFragment) {&#10;            navigator.navigate(com.prm.common.R.string.route_plan_management);&#10;            return true;&#10;        }&#10;&#10;        return NavigationUI.navigateUp(navController, appBarConfiguration)&#10;               || super.onSupportNavigateUp();&#10;    }&#10;&#10;    @Override&#10;    protected void onNewIntent(Intent intent) {&#10;        super.onNewIntent(intent);&#10;        try {&#10;            ZaloPaySDK.getInstance().onResult(intent);&#10;        } catch (Exception e) {&#10;            Log.e(&quot;MainActivity&quot;, &quot;Error handling ZaloPay result&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        // Pause ad timer when activity is not visible&#10;        stopAdTimer();&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        // Resume ad timer when activity becomes visible&#10;        startAdTimer();&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        stopProgressUpdates();&#10;        stopAdTimer();&#10;        if (miniPlayerViewModel != null) {&#10;            miniPlayerViewModel.disconnect();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/prm/musicstreaming/MainViewModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/prm/musicstreaming/MainViewModel.java" />
              <option name="updatedContent" value="package com.prm.musicstreaming;&#10;&#10;import androidx.lifecycle.LiveData;&#10;import androidx.lifecycle.MutableLiveData;&#10;import androidx.lifecycle.ViewModel;&#10;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.prm.domain.repository.UserRepository;&#10;&#10;import javax.inject.Inject;&#10;&#10;import dagger.hilt.android.lifecycle.HiltViewModel;&#10;import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers;&#10;import io.reactivex.rxjava3.disposables.CompositeDisposable;&#10;import io.reactivex.rxjava3.schedulers.Schedulers;&#10;&#10;@HiltViewModel&#10;public class MainViewModel extends ViewModel {&#10;    &#10;    private final UserRepository userRepository;&#10;    private final CompositeDisposable disposables = new CompositeDisposable();&#10;    &#10;    private final MutableLiveData&lt;Boolean&gt; _shouldShowAds = new MutableLiveData&lt;&gt;(true);&#10;    public LiveData&lt;Boolean&gt; shouldShowAds = _shouldShowAds;&#10;    &#10;    private final MutableLiveData&lt;Boolean&gt; _isUserRegistered = new MutableLiveData&lt;&gt;(false);&#10;    public LiveData&lt;Boolean&gt; isUserRegistered = _isUserRegistered;&#10;&#10;    @Inject&#10;    public MainViewModel(UserRepository userRepository) {&#10;        this.userRepository = userRepository;&#10;        checkUserRegistration();&#10;    }&#10;&#10;    private void checkUserRegistration() {&#10;        FirebaseUser currentUser = FirebaseAuth.getInstance().getCurrentUser();&#10;        if (currentUser == null) {&#10;            _shouldShowAds.setValue(true);&#10;            _isUserRegistered.setValue(false);&#10;            return;&#10;        }&#10;&#10;        String userId = currentUser.getUid();&#10;        disposables.add(&#10;            userRepository.checkUserExistsByUserId(userId)&#10;                .subscribeOn(Schedulers.io())&#10;                .observeOn(AndroidSchedulers.mainThread())&#10;                .subscribe(&#10;                    exists -&gt; {&#10;                        _isUserRegistered.setValue(exists);&#10;                        // Turn off ads if user exists in repository (registered user)&#10;                        _shouldShowAds.setValue(!exists);&#10;                    },&#10;                    error -&gt; {&#10;                        // On error, default to showing ads and user not registered&#10;                        _shouldShowAds.setValue(true);&#10;                        _isUserRegistered.setValue(false);&#10;                    }&#10;                )&#10;        );&#10;    }&#10;&#10;    public void refreshUserStatus() {&#10;        checkUserRegistration();&#10;    }&#10;&#10;    @Override&#10;    protected void onCleared() {&#10;        super.onCleared();&#10;        disposables.clear();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>